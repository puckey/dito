"use strict";

exports.__esModule = true;
exports.getAllKeys = getAllKeys;
exports.getOwnProperty = getOwnProperty;
exports.createLookup = createLookup;
exports.mergeReversed = mergeReversed;
exports.mergeReversedOrNull = mergeReversedOrNull;
exports.mergeAsReversedArrays = mergeAsReversedArrays;
exports.setupPropertyInheritance = setupPropertyInheritance;

var _utils = require("@ditojs/utils");

function getAllKeys(object) {
  const keys = [];

  for (const key in object) {
    keys.push(key);
  }

  return keys;
}

function getOwnProperty(object, key) {
  return object.hasOwnProperty(key) ? object[key] : undefined;
}

function createLookup(keys) {
  return (0, _utils.asArray)(keys).reduce((obj, key) => {
    obj[key] = true;
    return obj;
  }, Object.create(null));
}

function mergeReversed(objects) {
  return Object.assign({}, ...[...objects].reverse());
}

function mergeReversedOrNull(objects) {
  const merged = mergeReversed(objects);
  return Object.keys(merged).length > 0 ? merged : null;
}

function mergeAsReversedArrays(objects) {
  const res = {};

  for (const object of objects) {
    for (const key in object) {
      const value = object[key];

      if (key in res) {
        res[key].unshift(value);
      } else {
        res[key] = [value];
      }
    }
  }

  return res;
}

function setupPropertyInheritance(object, key, baseValue = null) {
  let current = object;

  while (current !== Object.prototype) {
    const parent = Object.getPrototypeOf(current);

    if (current.hasOwnProperty(key)) {
      const value = current[key];
      const parentValue = parent[key] || baseValue;

      if (parentValue) {
        Object.setPrototypeOf(value, parentValue);
      }
    }

    current = parent;
  }

  if (baseValue && !(key in object)) {
    object[key] = Object.setPrototypeOf({}, baseValue);
  }

  return object[key];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9vYmplY3QuanMiXSwibmFtZXMiOlsiZ2V0QWxsS2V5cyIsIm9iamVjdCIsImtleXMiLCJrZXkiLCJwdXNoIiwiZ2V0T3duUHJvcGVydHkiLCJoYXNPd25Qcm9wZXJ0eSIsInVuZGVmaW5lZCIsImNyZWF0ZUxvb2t1cCIsInJlZHVjZSIsIm9iaiIsIk9iamVjdCIsImNyZWF0ZSIsIm1lcmdlUmV2ZXJzZWQiLCJvYmplY3RzIiwiYXNzaWduIiwicmV2ZXJzZSIsIm1lcmdlUmV2ZXJzZWRPck51bGwiLCJtZXJnZWQiLCJsZW5ndGgiLCJtZXJnZUFzUmV2ZXJzZWRBcnJheXMiLCJyZXMiLCJ2YWx1ZSIsInVuc2hpZnQiLCJzZXR1cFByb3BlcnR5SW5oZXJpdGFuY2UiLCJiYXNlVmFsdWUiLCJjdXJyZW50IiwicHJvdG90eXBlIiwicGFyZW50IiwiZ2V0UHJvdG90eXBlT2YiLCJwYXJlbnRWYWx1ZSIsInNldFByb3RvdHlwZU9mIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUVPLFNBQVNBLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCO0FBRWpDLFFBQU1DLElBQUksR0FBRyxFQUFiOztBQUNBLE9BQUssTUFBTUMsR0FBWCxJQUFrQkYsTUFBbEIsRUFBMEI7QUFDeEJDLElBQUFBLElBQUksQ0FBQ0UsSUFBTCxDQUFVRCxHQUFWO0FBQ0Q7O0FBQ0QsU0FBT0QsSUFBUDtBQUNEOztBQUVNLFNBQVNHLGNBQVQsQ0FBd0JKLE1BQXhCLEVBQWdDRSxHQUFoQyxFQUFxQztBQUMxQyxTQUFPRixNQUFNLENBQUNLLGNBQVAsQ0FBc0JILEdBQXRCLElBQTZCRixNQUFNLENBQUNFLEdBQUQsQ0FBbkMsR0FBMkNJLFNBQWxEO0FBQ0Q7O0FBRU0sU0FBU0MsWUFBVCxDQUFzQk4sSUFBdEIsRUFBNEI7QUFDakMsU0FBTyxvQkFBUUEsSUFBUixFQUFjTyxNQUFkLENBQXFCLENBQUNDLEdBQUQsRUFBTVAsR0FBTixLQUFjO0FBQ3hDTyxJQUFBQSxHQUFHLENBQUNQLEdBQUQsQ0FBSCxHQUFXLElBQVg7QUFDQSxXQUFPTyxHQUFQO0FBQ0QsR0FITSxFQUdKQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxJQUFkLENBSEksQ0FBUDtBQUlEOztBQUVNLFNBQVNDLGFBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDO0FBQ3JDLFNBQU9ILE1BQU0sQ0FBQ0ksTUFBUCxDQUFjLEVBQWQsRUFBa0IsR0FBRyxDQUFDLEdBQUdELE9BQUosRUFBYUUsT0FBYixFQUFyQixDQUFQO0FBQ0Q7O0FBRU0sU0FBU0MsbUJBQVQsQ0FBNkJILE9BQTdCLEVBQXNDO0FBQzNDLFFBQU1JLE1BQU0sR0FBR0wsYUFBYSxDQUFDQyxPQUFELENBQTVCO0FBQ0EsU0FBT0gsTUFBTSxDQUFDVCxJQUFQLENBQVlnQixNQUFaLEVBQW9CQyxNQUFwQixHQUE2QixDQUE3QixHQUFpQ0QsTUFBakMsR0FBMEMsSUFBakQ7QUFDRDs7QUFFTSxTQUFTRSxxQkFBVCxDQUErQk4sT0FBL0IsRUFBd0M7QUFDN0MsUUFBTU8sR0FBRyxHQUFHLEVBQVo7O0FBQ0EsT0FBSyxNQUFNcEIsTUFBWCxJQUFxQmEsT0FBckIsRUFBOEI7QUFDNUIsU0FBSyxNQUFNWCxHQUFYLElBQWtCRixNQUFsQixFQUEwQjtBQUN4QixZQUFNcUIsS0FBSyxHQUFHckIsTUFBTSxDQUFDRSxHQUFELENBQXBCOztBQUNBLFVBQUlBLEdBQUcsSUFBSWtCLEdBQVgsRUFBZ0I7QUFDZEEsUUFBQUEsR0FBRyxDQUFDbEIsR0FBRCxDQUFILENBQVNvQixPQUFULENBQWlCRCxLQUFqQjtBQUNELE9BRkQsTUFFTztBQUNMRCxRQUFBQSxHQUFHLENBQUNsQixHQUFELENBQUgsR0FBVyxDQUFDbUIsS0FBRCxDQUFYO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFNBQU9ELEdBQVA7QUFDRDs7QUFFTSxTQUFTRyx3QkFBVCxDQUFrQ3ZCLE1BQWxDLEVBQTBDRSxHQUExQyxFQUErQ3NCLFNBQVMsR0FBRyxJQUEzRCxFQUFpRTtBQUl0RSxNQUFJQyxPQUFPLEdBQUd6QixNQUFkOztBQUNBLFNBQU95QixPQUFPLEtBQUtmLE1BQU0sQ0FBQ2dCLFNBQTFCLEVBQXFDO0FBQ25DLFVBQU1DLE1BQU0sR0FBR2pCLE1BQU0sQ0FBQ2tCLGNBQVAsQ0FBc0JILE9BQXRCLENBQWY7O0FBQ0EsUUFBSUEsT0FBTyxDQUFDcEIsY0FBUixDQUF1QkgsR0FBdkIsQ0FBSixFQUFpQztBQUMvQixZQUFNbUIsS0FBSyxHQUFHSSxPQUFPLENBQUN2QixHQUFELENBQXJCO0FBQ0EsWUFBTTJCLFdBQVcsR0FBR0YsTUFBTSxDQUFDekIsR0FBRCxDQUFOLElBQWVzQixTQUFuQzs7QUFDQSxVQUFJSyxXQUFKLEVBQWlCO0FBQ2ZuQixRQUFBQSxNQUFNLENBQUNvQixjQUFQLENBQXNCVCxLQUF0QixFQUE2QlEsV0FBN0I7QUFDRDtBQUNGOztBQUNESixJQUFBQSxPQUFPLEdBQUdFLE1BQVY7QUFDRDs7QUFDRCxNQUFJSCxTQUFTLElBQUksRUFBRXRCLEdBQUcsSUFBSUYsTUFBVCxDQUFqQixFQUFtQztBQUdqQ0EsSUFBQUEsTUFBTSxDQUFDRSxHQUFELENBQU4sR0FBY1EsTUFBTSxDQUFDb0IsY0FBUCxDQUFzQixFQUF0QixFQUEwQk4sU0FBMUIsQ0FBZDtBQUNEOztBQUNELFNBQU94QixNQUFNLENBQUNFLEdBQUQsQ0FBYjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNBcnJheSB9IGZyb20gJ0BkaXRvanMvdXRpbHMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAvLyBVbmxpa2UgYE9iamVjdC5rZXlzKClgLCB0aGlzIHJldHVybnMgYWxsIGVudW1lcmFibGUga2V5cyBub3QganVzdCBvd24gb25lcy5cbiAgY29uc3Qga2V5cyA9IFtdXG4gIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgIGtleXMucHVzaChrZXkpXG4gIH1cbiAgcmV0dXJuIGtleXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE93blByb3BlcnR5KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSA/IG9iamVjdFtrZXldIDogdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMb29rdXAoa2V5cykge1xuICByZXR1cm4gYXNBcnJheShrZXlzKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgb2JqW2tleV0gPSB0cnVlXG4gICAgcmV0dXJuIG9ialxuICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VSZXZlcnNlZChvYmplY3RzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCAuLi5bLi4ub2JqZWN0c10ucmV2ZXJzZSgpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VSZXZlcnNlZE9yTnVsbChvYmplY3RzKSB7XG4gIGNvbnN0IG1lcmdlZCA9IG1lcmdlUmV2ZXJzZWQob2JqZWN0cylcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubGVuZ3RoID4gMCA/IG1lcmdlZCA6IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQXNSZXZlcnNlZEFycmF5cyhvYmplY3RzKSB7XG4gIGNvbnN0IHJlcyA9IHt9XG4gIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV1cbiAgICAgIGlmIChrZXkgaW4gcmVzKSB7XG4gICAgICAgIHJlc1trZXldLnVuc2hpZnQodmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNba2V5XSA9IFt2YWx1ZV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBQcm9wZXJ0eUluaGVyaXRhbmNlKG9iamVjdCwga2V5LCBiYXNlVmFsdWUgPSBudWxsKSB7XG4gIC8vIExvb3BzIHVwIHRoZSBpbmhlcml0YW5jZSBjaGFpbiBvZiBvYmplY3QgdW50aWwgdGhlIGJhc2Ugb2JqZWN0IGlzIG1ldCxcbiAgLy8gYW5kIHNldHMgdXAgYSByZWxhdGVkIGluaGVyaXRhbmNlIGNoYWluIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgYGtleWAuXG4gIC8vIEF0IHRoZSBlbmQsIHRoZSByZXN1bHRpbmcgdmFsdWUgd2l0aCBwcm9wZXIgaW5oZXJpdGFuY2UgaXMgcmV0dXJuZWQuXG4gIGxldCBjdXJyZW50ID0gb2JqZWN0XG4gIHdoaWxlIChjdXJyZW50ICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgY29uc3QgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN1cnJlbnQpXG4gICAgaWYgKGN1cnJlbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50W2tleV1cbiAgICAgIGNvbnN0IHBhcmVudFZhbHVlID0gcGFyZW50W2tleV0gfHwgYmFzZVZhbHVlXG4gICAgICBpZiAocGFyZW50VmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHZhbHVlLCBwYXJlbnRWYWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudCA9IHBhcmVudFxuICB9XG4gIGlmIChiYXNlVmFsdWUgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgIC8vIElmIHRoZXJlIHdhc24ndCBhbnkgb3ZlcnJpZGUgaW4gdGhlIGNoYWluLCBhbmQgd2UgaGF2ZSBhIGJhc2VWYWx1ZSxcbiAgICAvLyBzZXQgdXAgZGlyZWN0IGluaGVyaXRhbmNlIGZyb20gdGhhdCBub3cuXG4gICAgb2JqZWN0W2tleV0gPSBPYmplY3Quc2V0UHJvdG90eXBlT2Yoe30sIGJhc2VWYWx1ZSlcbiAgfVxuICByZXR1cm4gb2JqZWN0W2tleV1cbn1cbiJdfQ==